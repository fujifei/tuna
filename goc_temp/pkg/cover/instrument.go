/*
 Copyright 2020 Qiniu Cloud (qiniu.com)

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package cover

import (
	"fmt"
	"os"
	"path"
	"path/filepath"
	"text/template"
)

// InjectCountersHandlers generate a file _cover_http_apis.go besides the main.go file
func InjectCountersHandlers(tc TestCover, dest string) error {
	f, err := os.Create(dest)
	if err != nil {
		return err
	}
	if err := coverMainTmpl.Execute(f, tc); err != nil {
		return err
	}
	return nil
}

var coverMainTmpl = template.Must(template.New("coverMain").Parse(coverMain))

const coverMain = `
// Code generated by goc system. DO NOT EDIT.

package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	_log "log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync/atomic"
	"syscall"
	"testing"
	"time"

	_cover {{.GlobalCoverVarImportPath | printf "%q"}}

)

// Global variables for coverage reporting
var (
	gocReportURL  = {{.RabbitMQURL | printf "%q"}}  // HTTP endpoint for coverage reporting (RabbitMQ HTTP API or custom webhook)
	gocGitInfo    *gocGitInfoStruct
	gocCIInfo     *gocCIMetadataStruct
)

// CoverageReportMessage represents the structured coverage data for RabbitMQ
type gocCoverageReportMessageStruct struct {
	Repo      string              ` + "`" + `json:"repo"` + "`" + `
	RepoID    string              ` + "`" + `json:"repo_id"` + "`" + `
	Branch    string              ` + "`" + `json:"branch"` + "`" + `
	Commit    string              ` + "`" + `json:"commit"` + "`" + `
	CI        gocCIMetadataStruct ` + "`" + `json:"ci"` + "`" + `
	Coverage  gocCoverageData     ` + "`" + `json:"coverage"` + "`" + `
	Timestamp int64               ` + "`" + `json:"timestamp"` + "`" + `
}

// CIMetadata contains CI information
type gocCIMetadataStruct struct {
	Provider   string ` + "`" + `json:"provider"` + "`" + `
	PipelineID string ` + "`" + `json:"pipeline_id"` + "`" + `
	JobID      string ` + "`" + `json:"job_id"` + "`" + `
}

// CoverageData contains coverage format and raw data
type gocCoverageData struct {
	Format string ` + "`" + `json:"format"` + "`" + `
	Raw    string ` + "`" + `json:"raw"` + "`" + `
}

// GitInfo contains git repository information
type gocGitInfoStruct struct {
	Repo   string
	RepoID string
	Branch string
	Commit string
}

func init() {
	go registerHandlersGoc()
}

func loadValuesGoc() (map[string][]uint32, map[string][]testing.CoverBlock) {
	var (
		coverCounters = make(map[string][]uint32)
		coverBlocks   = make(map[string][]testing.CoverBlock)
	)

	{{range $i, $pkgCover := .DepsCover}}
	{{range $file, $cover := $pkgCover.Vars}}
	loadFileCoverGoc(coverCounters, coverBlocks, {{printf "%q" $cover.File}}, _cover.{{$cover.Var}}.Count[:], _cover.{{$cover.Var}}.Pos[:], _cover.{{$cover.Var}}.NumStmt[:])
	{{end}}
	{{end}}

	{{range $file, $cover := .MainPkgCover.Vars}}
	loadFileCoverGoc(coverCounters, coverBlocks, {{printf "%q" $cover.File}}, _cover.{{$cover.Var}}.Count[:], _cover.{{$cover.Var}}.Pos[:], _cover.{{$cover.Var}}.NumStmt[:])
	{{end}}

	return coverCounters, coverBlocks
}

func loadFileCoverGoc(coverCounters map[string][]uint32, coverBlocks map[string][]testing.CoverBlock, fileName string, counter []uint32, pos []uint32, numStmts []uint16) {
	if 3*len(counter) != len(pos) || len(counter) != len(numStmts) {
		panic("coverage: mismatched sizes")
	}
	if coverCounters[fileName] != nil {
		// Already registered.
		return
	}
	coverCounters[fileName] = counter
	block := make([]testing.CoverBlock, len(counter))
	for i := range counter {
		block[i] = testing.CoverBlock{
			Line0: pos[3*i+0],
			Col0:  uint16(pos[3*i+2]),
			Line1: pos[3*i+1],
			Col1:  uint16(pos[3*i+2] >> 16),
			Stmts: numStmts[i],
		}
	}
	coverBlocks[fileName] = block
}

func clearValuesGoc() {

	{{range $i, $pkgCover := .DepsCover}}
	{{range $file, $cover := $pkgCover.Vars}}
	clearFileCoverGoc(_cover.{{$cover.Var}}.Count[:])
	{{end}}
	{{end}}

	{{range $file, $cover := .MainPkgCover.Vars}}
	clearFileCoverGoc(_cover.{{$cover.Var}}.Count[:])
	{{end}}

}

func clearFileCoverGoc(counter []uint32) {
	for i := range counter {
		counter[i] = 0
	}
}

// collectAndReportCoverageGoc collects coverage data and reports it to MQ
func collectAndReportCoverageGoc() {
	if gocReportURL == "" {
		_log.Printf("[goc][WARN] collectAndReportCoverageGoc called but gocReportURL is empty, skipping report")
		return
	}
	
	_log.Printf("[goc][DEBUG] collectAndReportCoverageGoc: gocReportURL=%s, starting collection...", gocReportURL)

	// Collect coverage data
	var coverageBuffer bytes.Buffer
	fmt.Fprintf(&coverageBuffer, "mode: {{.Mode}}\n")
	
	counters, blocks := loadValuesGoc()
	var active, total int64
	var count uint32
	for name, counts := range counters {
		block := blocks[name]
		for i := range counts {
			stmts := int64(block[i].Stmts)
			total += stmts
			count = atomic.LoadUint32(&counts[i]) // For -mode=atomic.
			if count > 0 {
				active += stmts
			}
			fmt.Fprintf(&coverageBuffer, "%s:%d.%d,%d.%d %d %d\n", name,
				block[i].Line0, block[i].Col0,
				block[i].Line1, block[i].Col1,
				stmts,
				count)
		}
	}

	coverageData := coverageBuffer.String()
	_log.Printf("[goc][DEBUG] Coverage data collected: length=%d bytes, files=%d", len(coverageData), len(counters))

	// Report coverage
	report := gocCoverageReportMessageStruct{
		Repo:      gocGitInfo.Repo,
		RepoID:    gocGitInfo.RepoID,
		Branch:    gocGitInfo.Branch,
		Commit:    gocGitInfo.Commit,
		CI:        *gocCIInfo,
		Coverage: gocCoverageData{
			Format: "goc",
			Raw:    coverageData,
		},
		Timestamp: time.Now().Unix(),
	}
	
	_log.Printf("[goc][DEBUG] Publishing coverage report: repo=%s, repo_id=%s, branch=%s, commit=%s, url=%s", 
		report.Repo, report.RepoID, report.Branch, report.Commit, gocReportURL)
	
	if err := publishCoverageReportGoc(report); err != nil {
		_log.Printf("[goc][WARN] Failed to publish coverage report: %v", err)
		_log.Printf("[goc][WARN] Report URL was: %s", gocReportURL)
	} else {
		_log.Printf("[goc][INFO] Successfully published coverage report (scheduled)")
	}
}

func registerHandlersGoc() {
	// Initialize Git and CI information
	gocGitInfo = getGitInfoGoc()
	gocCIInfo = getCIInfoGoc()

	// Always log gocReportURL status for debugging
	if gocReportURL == "" {
		_log.Printf("[goc][WARN] gocReportURL is EMPTY - coverage reporting is DISABLED")
		_log.Printf("[goc][WARN] To enable coverage reporting, use: goc build --rabbitmq-url=amqp://...")
	} else {
		_log.Printf("[goc][INFO] gocReportURL is set: %s", gocReportURL)
		_log.Printf("[goc][INFO] Coverage reporting enabled to: %s", gocReportURL)
		_log.Printf("[goc][INFO] Git info: repo=%s, repo_id=%s, branch=%s, commit=%s", 
			gocGitInfo.Repo, gocGitInfo.RepoID, gocGitInfo.Branch, gocGitInfo.Commit)
		
		// Start periodic coverage reporting (every minute)
		go func() {
			_log.Printf("[goc][DEBUG] Starting periodic coverage reporting goroutine")
			ticker := time.NewTicker(1 * time.Minute)
			defer ticker.Stop()
			
			// Report immediately on startup
			_log.Printf("[goc][DEBUG] Reporting coverage immediately on startup...")
			collectAndReportCoverageGoc()
			
			// Then report every minute
			_log.Printf("[goc][DEBUG] Periodic reporting started, will report every 1 minute")
			for range ticker.C {
				_log.Printf("[goc][DEBUG] Timer ticked, collecting and reporting coverage...")
				collectAndReportCoverageGoc()
			}
		}()
		_log.Printf("[goc][INFO] Started periodic coverage reporting (every 1 minute)")
	}

	{{if .Singleton}}
	ln, _, err := listenGoc()
	{{else}}
	ln, host, err := listenGoc()
	{{end}}
	if err != nil {
		_log.Fatalf("listenGoc failed, err:%v", err)
	}
	{{if not .Singleton}}
	profileAddr := "http://" + host
	if resp, err := registerSelfGoc(profileAddr); err != nil {
		_log.Fatalf("register address %v failed, err: %v, response: %v", profileAddr, err, string(resp))
	}

	fn := func() {
		var (
			err          error
			profileAddrs []string
			addresses    []string
		)
		if addresses, err = getAllHostsGoc(ln); err != nil {
			_log.Fatalf("get all host failed, err: %v", err)
			return
		}
		for _, addr := range addresses {
			profileAddrs = append(profileAddrs, "http://"+addr)
		}
		deregisterSelfGoc(profileAddrs)
	}
	go watchSignalGoc(fn)
	{{end}}

	mux := http.NewServeMux()
	// Coverage reports the current code coverage as a fraction in the range [0, 1].
	// If coverage is not enabled, Coverage returns 0.
	mux.HandleFunc("/v1/cover/coverage", func(w http.ResponseWriter, r *http.Request) {
		counters, _ := loadValuesGoc()
		var n, d int64
		for _, counter := range counters {
			for i := range counter {
				if atomic.LoadUint32(&counter[i]) > 0 {
					n++
				}
				d++
			}
		}
		if d == 0 {
			fmt.Fprint(w, 0)
			return
		}
		fmt.Fprintf(w, "%f", float64(n)/float64(d))
	})

	// coverprofile reports a coverage profile with the coverage percentage
	mux.HandleFunc("/v1/cover/profile", func(w http.ResponseWriter, r *http.Request) {
		// Collect coverage data
		var coverageBuffer bytes.Buffer
		fmt.Fprintf(&coverageBuffer, "mode: {{.Mode}}\n")
		
		counters, blocks := loadValuesGoc()
		var active, total int64
		var count uint32
		for name, counts := range counters {
			block := blocks[name]
			for i := range counts {
				stmts := int64(block[i].Stmts)
				total += stmts
				count = atomic.LoadUint32(&counts[i]) // For -mode=atomic.
				if count > 0 {
					active += stmts
				}
				fmt.Fprintf(&coverageBuffer, "%s:%d.%d,%d.%d %d %d\n", name,
					block[i].Line0, block[i].Col0,
					block[i].Line1, block[i].Col1,
					stmts,
					count)
			}
		}

		coverageData := coverageBuffer.String()

		// Report coverage if reporting URL is configured (manual trigger via HTTP endpoint)
		if gocReportURL != "" {
			report := gocCoverageReportMessageStruct{
				Repo:      gocGitInfo.Repo,
				RepoID:    gocGitInfo.RepoID,
				Branch:    gocGitInfo.Branch,
				Commit:    gocGitInfo.Commit,
				CI:        *gocCIInfo,
				Coverage: gocCoverageData{
					Format: "goc",
					Raw:    coverageData,
				},
				Timestamp: time.Now().Unix(),
			}
			go func() {
				if err := publishCoverageReportGoc(report); err != nil {
					_log.Printf("[goc][WARN] Failed to publish coverage report (manual trigger): %v", err)
				} else {
					_log.Printf("[goc][INFO] Successfully published coverage report (manual trigger)")
				}
			}()
		}

		// Return coverage data in HTTP response
		fmt.Fprint(w, coverageData)
	})

	mux.HandleFunc("/v1/cover/clear", func(w http.ResponseWriter, r *http.Request) {
		clearValuesGoc()
		w.WriteHeader(http.StatusOK)
		fmt.Fprintln(w, "clear call successfully")
	})

	_log.Fatal(http.Serve(ln, mux))
}

func registerSelfGoc(address string) ([]byte, error) {
	customServiceName, ok := os.LookupEnv("GOC_SERVICE_NAME")
	var selfName string
	if ok {
		selfName = customServiceName
	} else {
		selfName = filepath.Base(os.Args[0])
	}
	req, err := http.NewRequest("POST", fmt.Sprintf("%s/v1/cover/register?name=%s&address=%s", {{.Center | printf "%q"}}, selfName, address), nil)
	if err != nil {
		_log.Fatalf("http.NewRequest failed: %v", err)
		return nil, err
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil && isNetworkErrorGoc(err) {
		_log.Printf("[goc][WARN]error occurred:%v, try again", err)
		resp, err = http.DefaultClient.Do(req)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to register into coverage center, err:%v", err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body, err:%v", err)
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("failed to register into coverage center, response code %d", resp.StatusCode)
	}

	return body, err
}

func deregisterSelfGoc(address []string) ([]byte, error) {
	param := map[string]interface{}{
		"address": address,
	}
	jsonBody, err := json.Marshal(param)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", fmt.Sprintf("%s/v1/cover/remove", {{.Center | printf "%q"}}), bytes.NewReader(jsonBody))
	if err != nil {
		_log.Fatalf("http.NewRequest failed: %v", err)
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil && isNetworkErrorGoc(err) {
		_log.Printf("[goc][WARN]error occurred:%v, try again", err)
		resp, err = http.DefaultClient.Do(req)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to deregister into coverage center, err:%v", err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body, err:%v", err)
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("failed to deregister into coverage center, response code %d", resp.StatusCode)
	}

	return body, err
}

type CallbackGocFunc func()

func watchSignalGoc(fn CallbackGocFunc) {
	// init signal
	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)
	for {
		si := <-c
		_log.Printf("get a signal %s", si.String())
		switch si {
		case syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:
			fn()
			os.Exit(0) // Exit successfully.
		case syscall.SIGHUP:
		default:
			return
		}
	}
}

func isNetworkErrorGoc(err error) bool {
	if err == io.EOF {
		return true
	}
	_, ok := err.(net.Error)
	return ok
}

func listenGoc() (ln net.Listener, host string, err error) {
	agentPort := "{{.AgentPort }}"
	if agentPort != "" {
		if ln, err = net.Listen("tcp4", agentPort); err != nil {
			return
		}
		if host, err = getRealHostGoc(ln); err != nil {
			return
		}
	} else {
		// 获取上次使用的监听地址
		if previousAddr := getPreviousAddrGoc(); previousAddr != "" {
			ss := strings.Split(previousAddr, ":")
			// listenGoc on all network interface
			ln, err = net.Listen("tcp4", ":"+ss[len(ss)-1])
			if err == nil {
				host = previousAddr
				return
			}
		}
		if ln, err = net.Listen("tcp4", ":0"); err != nil {
			return
		}
		if host, err = getRealHostGoc(ln); err != nil {
			return
		}
	}
	go genProfileAddrGoc(host)
	return
}

func getRealHostGoc(ln net.Listener) (host string, err error) {
	adds, err := net.InterfaceAddrs()
	if err != nil {
		return
	}

	var localIPV4 string
	var nonLocalIPV4 string
	for _, addr := range adds {
		if ipNet, ok := addr.(*net.IPNet); ok && ipNet.IP.To4() != nil {
			if ipNet.IP.IsLoopback() {
				localIPV4 = ipNet.IP.String()
			} else {
				nonLocalIPV4 = ipNet.IP.String()
			}
		}
	}
	if nonLocalIPV4 != "" {
		host = fmt.Sprintf("%s:%d", nonLocalIPV4, ln.Addr().(*net.TCPAddr).Port)
	} else {
		host = fmt.Sprintf("%s:%d", localIPV4, ln.Addr().(*net.TCPAddr).Port)
	}

	return
}

func getAllHostsGoc(ln net.Listener) (hosts []string, err error) {
	adds, err := net.InterfaceAddrs()
	if err != nil {
		return
	}

	var host string
	for _, addr := range adds {
		if ipNet, ok := addr.(*net.IPNet); ok && ipNet.IP.To4() != nil {
			host = fmt.Sprintf("%s:%d", ipNet.IP.String(), ln.Addr().(*net.TCPAddr).Port)
			hosts = append(hosts, host)
		}
	}
	return
}

func getPreviousAddrGoc() string {
	file, err := os.Open(os.Args[0] + "_profile_listen_addr")
	if err != nil {
		return ""
	}
	defer file.Close()

	reader := bufio.NewReader(file)
	addr, _, _ := reader.ReadLine()
	return string(addr)
}

func genProfileAddrGoc(profileAddr string) {
	fn := os.Args[0] + "_profile_listen_addr"
	f, err := os.OpenFile(fn, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		_log.Println(err)
		return
	}
	defer f.Close()

	fmt.Fprintf(f, strings.TrimPrefix(profileAddr, "http://"))
}

// getGitInfoGoc retrieves git repository information
func getGitInfoGoc() *gocGitInfoStruct {
	gitInfo := &gocGitInfoStruct{}
	wd, err := os.Getwd()
	if err != nil {
		return gitInfo
	}

	// Get repo URL
	if repo, err := getGitRemoteOriginGoc(wd); err == nil {
		gitInfo.Repo = repo
		_log.Printf("[goc][INFO] Successfully retrieved git repo: %s", repo)
		// Get repo_id from GitHub API
		if repoID, err := getGitHubRepoIDGoc(repo); err == nil {
			gitInfo.RepoID = repoID
			_log.Printf("[goc][INFO] Successfully retrieved git repo_id: %s", repoID)
		} else {
			_log.Printf("[goc][WARN] Failed to get GitHub repo ID: %v", err)
		}
	} else {
		_log.Printf("[goc][WARN] Failed to get git remote origin: %v", err)
	}

	// Get current branch
	if branch, err := getGitBranchGoc(wd); err == nil {
		gitInfo.Branch = branch
		_log.Printf("[goc][INFO] Successfully retrieved git branch: %s", branch)
	} else {
		_log.Printf("[goc][WARN] Failed to get git branch: %v", err)
	}

	// Get current commit
	if commit, err := getGitCommitGoc(wd); err == nil {
		gitInfo.Commit = commit
		_log.Printf("[goc][INFO] Successfully retrieved git commit: %s", commit)
	} else {
		_log.Printf("[goc][WARN] Failed to get git commit: %v", err)
	}

	return gitInfo
}

// findGitDirGoc finds the .git directory by traversing up the directory tree
func findGitDirGoc(startDir string) (string, error) {
	dir := startDir
	for {
		gitPath := filepath.Join(dir, ".git")
		if info, err := os.Stat(gitPath); err == nil && info.IsDir() {
			return gitPath, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf(".git directory not found")
		}
		dir = parent
	}
}

// getGitRemoteOriginGoc gets the remote origin URL
func getGitRemoteOriginGoc(wd string) (string, error) {
	gitDir, err := findGitDirGoc(wd)
	if err != nil {
		return "", err
	}

	configPath := filepath.Join(gitDir, "config")
	data, err := ioutil.ReadFile(configPath)
	if err != nil {
		return "", err
	}

	lines := strings.Split(string(data), "\n")
	for i, line := range lines {
		if strings.TrimSpace(line) == "[remote \"origin\"]" {
			for j := i + 1; j < len(lines) && j < i+10; j++ {
				trimmed := strings.TrimSpace(lines[j])
				if strings.HasPrefix(trimmed, "url = ") {
					return strings.TrimPrefix(trimmed, "url = "), nil
				}
			}
		}
	}
	return "", fmt.Errorf("remote origin URL not found")
}

// getGitBranchGoc gets the current branch name
func getGitBranchGoc(wd string) (string, error) {
	gitDir, err := findGitDirGoc(wd)
	if err != nil {
		return "", err
	}

	headPath := filepath.Join(gitDir, "HEAD")
	data, err := ioutil.ReadFile(headPath)
	if err != nil {
		return "", err
	}

	headContent := strings.TrimSpace(string(data))
	if strings.HasPrefix(headContent, "ref: refs/heads/") {
		return strings.TrimPrefix(headContent, "ref: refs/heads/"), nil
	}

	// Try git command as fallback
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = filepath.Dir(gitDir)
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(output)), nil
}

// getGitCommitGoc gets the current commit hash
func getGitCommitGoc(wd string) (string, error) {
	gitDir, err := findGitDirGoc(wd)
	if err != nil {
		return "", err
	}

	headPath := filepath.Join(gitDir, "HEAD")
	data, err := ioutil.ReadFile(headPath)
	if err != nil {
		return "", err
	}

	headContent := strings.TrimSpace(string(data))
	if strings.HasPrefix(headContent, "ref: ") {
		refPath := strings.TrimPrefix(headContent, "ref: ")
		refFile := filepath.Join(gitDir, refPath)
		if commitData, err := ioutil.ReadFile(refFile); err == nil {
			return strings.TrimSpace(string(commitData)), nil
		}
	} else {
		return headContent, nil
	}

	// Try git command as fallback
	cmd := exec.Command("git", "rev-parse", "HEAD")
	cmd.Dir = filepath.Dir(gitDir)
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(output)), nil
}

// getCIInfoGoc retrieves CI information from environment variables
func getCIInfoGoc() *gocCIMetadataStruct {
	ciInfo := &gocCIMetadataStruct{}

	// GitLab CI
	if pipelineID := os.Getenv("CI_PIPELINE_ID"); pipelineID != "" {
		ciInfo.Provider = "gitlab"
		ciInfo.PipelineID = pipelineID
		ciInfo.JobID = os.Getenv("CI_JOB_ID")
		return ciInfo
	}

	// Jenkins
	if buildNumber := os.Getenv("BUILD_NUMBER"); buildNumber != "" {
		ciInfo.Provider = "jenkins"
		ciInfo.PipelineID = buildNumber
		ciInfo.JobID = os.Getenv("JOB_NAME")
		return ciInfo
	}

	// GitHub Actions
	if runID := os.Getenv("GITHUB_RUN_ID"); runID != "" {
		ciInfo.Provider = "github"
		ciInfo.PipelineID = runID
		ciInfo.JobID = os.Getenv("GITHUB_JOB")
		return ciInfo
	}

	// CircleCI
	if buildNum := os.Getenv("CIRCLE_BUILD_NUM"); buildNum != "" {
		ciInfo.Provider = "circleci"
		ciInfo.PipelineID = buildNum
		ciInfo.JobID = os.Getenv("CIRCLE_JOB")
		return ciInfo
	}

	return ciInfo
}

// parseGitHubRepoURLGoc extracts owner and repo name from various git URL formats
func parseGitHubRepoURLGoc(repoURL string) (owner, repo string, err error) {
	// Remove .git suffix if present
	repoURL = strings.TrimSuffix(repoURL, ".git")

	// Pattern 1: https://github.com/owner/repo
	// Pattern 2: git@github.com:owner/repo
	// Pattern 3: git://github.com/owner/repo
	patterns := []*regexp.Regexp{
		regexp.MustCompile("(?i)^https?://github\\.com/([^/]+)/([^/]+)/?$"),
		regexp.MustCompile("(?i)^git@github\\.com:([^/]+)/([^/]+)/?$"),
		regexp.MustCompile("(?i)^git://github\\.com/([^/]+)/([^/]+)/?$"),
	}

	for _, pattern := range patterns {
		matches := pattern.FindStringSubmatch(repoURL)
		if len(matches) == 3 {
			return matches[1], matches[2], nil
		}
	}

	return "", "", fmt.Errorf("unable to parse GitHub repo URL: %s", repoURL)
}

// gocGitHubRepoResponse represents the response from GitHub API
type gocGitHubRepoResponse struct {
	ID int64 ` + "`" + `json:"id"` + "`" + `
}

// getGitHubRepoIDGoc fetches the repository ID from GitHub API
func getGitHubRepoIDGoc(repoURL string) (string, error) {
	// Parse owner and repo from URL
	owner, repo, err := parseGitHubRepoURLGoc(repoURL)
	if err != nil {
		return "", err
	}
	_log.Printf("[goc][DEBUG] Parsed GitHub repo URL - owner: %s, repo: %s", owner, repo)

	// Build GitHub API URL
	apiURL := fmt.Sprintf("https://api.github.com/repos/%s/%s", owner, repo)
	_log.Printf("[goc][DEBUG] Calling GitHub API: %s", apiURL)

	// Create HTTP client with timeout
	client := &http.Client{
		Timeout: 10 * time.Second,
	}

	// Make request to GitHub API
	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %v", err)
	}

	// Set User-Agent header (GitHub API requires this)
	req.Header.Set("User-Agent", "goc-wrapper")

	// Make the request
	resp, err := client.Do(req)
	if err != nil {
		_log.Printf("[goc][WARN] Failed to call GitHub API %s: %v", apiURL, err)
		return "", fmt.Errorf("failed to call GitHub API: %v", err)
	}
	defer resp.Body.Close()

	// Check status code
	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		_log.Printf("[goc][WARN] GitHub API returned non-200 status: %d, body: %s", resp.StatusCode, string(body))
		return "", fmt.Errorf("GitHub API returned status %d: %s", resp.StatusCode, string(body))
	}

	// Parse JSON response
	var repoResponse gocGitHubRepoResponse
	if err := json.NewDecoder(resp.Body).Decode(&repoResponse); err != nil {
		return "", fmt.Errorf("failed to parse GitHub API response: %v", err)
	}

	// Convert ID to string
	repoID := strconv.FormatInt(repoResponse.ID, 10)
	_log.Printf("[goc][DEBUG] Successfully retrieved repo ID from GitHub API: %s", repoID)
	return repoID, nil
}

// publishCoverageReportGoc publishes the coverage report via HTTP
// Supports RabbitMQ HTTP Management API, custom webhooks, or any HTTP endpoint
func publishCoverageReportGoc(report gocCoverageReportMessageStruct) error {
	_log.Printf("[goc][DEBUG] publishCoverageReportGoc: original URL=%s", gocReportURL)
	
	jsonData, err := json.Marshal(report)
	if err != nil {
		return fmt.Errorf("failed to marshal report: %v", err)
	}
	_log.Printf("[goc][DEBUG] JSON payload size: %d bytes", len(jsonData))

	// Check if URL starts with "amqp://" - convert to HTTP Management API
	reportURL := gocReportURL
	isRabbitMQAPI := false
	if strings.HasPrefix(reportURL, "amqp://") {
		// Convert amqp://user:pass@host:port/ to http://host:15672/api/...
		reportURL = convertAMQPToHTTPGoc(reportURL)
		isRabbitMQAPI = true
		_log.Printf("[goc][DEBUG] Converted AMQP URL to HTTP: %s", reportURL)
	} else {
		_log.Printf("[goc][DEBUG] Using HTTP URL directly: %s", reportURL)
	}

	var requestBody []byte
	if isRabbitMQAPI {
		// Format for RabbitMQ HTTP Management API
		rabbitMQPayload := map[string]interface{}{
			"properties": map[string]string{
				"content_type": "application/json",
			},
			"routing_key":      "coverage.report",
			"payload":          string(jsonData),
			"payload_encoding": "string",
		}
		requestBody, err = json.Marshal(rabbitMQPayload)
		if err != nil {
			return fmt.Errorf("failed to marshal RabbitMQ payload: %v", err)
		}
	} else {
		// Direct JSON payload for custom webhooks
		requestBody = jsonData
	}

	// Create HTTP request
	_log.Printf("[goc][DEBUG] Creating HTTP POST request to: %s", reportURL)
	req, err := http.NewRequest("POST", reportURL, bytes.NewReader(requestBody))
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")

	// Send request with timeout
	_log.Printf("[goc][DEBUG] Sending HTTP request...")
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		_log.Printf("[goc][ERROR] HTTP request failed: %v", err)
		return fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	_log.Printf("[goc][DEBUG] HTTP response status: %d", resp.StatusCode)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := ioutil.ReadAll(resp.Body)
		_log.Printf("[goc][ERROR] HTTP error response body: %s", string(body))
		return fmt.Errorf("server returned status %d: %s", resp.StatusCode, string(body))
	}

	_log.Printf("[goc][DEBUG] Coverage report published successfully: repo=%s, repo_id=%s, branch=%s, commit=%s", 
		report.Repo, report.RepoID, report.Branch, report.Commit)
	return nil
}

// convertAMQPToHTTPGoc converts AMQP URL to RabbitMQ HTTP Management API URL
func convertAMQPToHTTPGoc(amqpURL string) string {
	// Parse amqp://user:pass@host:port/vhost
	// Convert to http://host:15672/api/exchanges/vhost/coverage_exchange/publish
	
	// Remove amqp:// prefix
	url := strings.TrimPrefix(amqpURL, "amqp://")
	
	// Extract credentials and host
	var user, pass, host string
	var port = "15672" // Default RabbitMQ HTTP management port
	
	if atIdx := strings.Index(url, "@"); atIdx != -1 {
		creds := url[:atIdx]
		url = url[atIdx+1:]
		
		if colonIdx := strings.Index(creds, ":"); colonIdx != -1 {
			user = creds[:colonIdx]
			pass = creds[colonIdx+1:]
		}
	}
	
	// Extract host and port
	if colonIdx := strings.Index(url, ":"); colonIdx != -1 {
		host = url[:colonIdx]
		remaining := url[colonIdx+1:]
		if slashIdx := strings.Index(remaining, "/"); slashIdx != -1 {
			// Port is specified in AMQP URL, but we need HTTP management port
			remaining = remaining[slashIdx+1:]
		}
	} else if slashIdx := strings.Index(url, "/"); slashIdx != -1 {
		host = url[:slashIdx]
	} else {
		host = url
	}
	
	// Build HTTP Management API URL
	// Using the API to publish directly to an exchange
	httpURL := fmt.Sprintf("http://%s:%s/api/exchanges/%%2F/coverage_exchange/publish", host, port)
	
	// Add basic auth if credentials are present
	if user != "" && pass != "" {
		httpURL = fmt.Sprintf("http://%s:%s@%s:%s/api/exchanges/%%2F/coverage_exchange/publish", 
			user, pass, host, port)
	}
	
	return httpURL
}
`

var coverParentFileTmpl = template.Must(template.New("coverParentFileTmpl").Parse(coverParentFile))

const coverParentFile = `
// Code generated by goc system. DO NOT EDIT.

package {{.}}

`

var coverParentVarsTmpl = template.Must(template.New("coverParentVarsTmpl").Parse(coverParentVars))

const coverParentVars = `

import (

	{{range $i, $pkgCover := .}}
	_cover{{$i}} {{$pkgCover.Package.ImportPath | printf "%q"}}
	{{end}} 

)

{{range $i, $pkgCover := .}}
{{range $v, $cover := $pkgCover.Vars}}
var {{$v}} = &_cover{{$i}}.{{$cover.Var}}
{{end}}
{{end}}
	
`

func InjectCacheCounters(covers map[string][]*PackageCover, cache map[string]*PackageCover) []error {
	var errs []error
	for k, v := range covers {
		if pkg, ok := cache[k]; ok {
			err := checkCacheDir(pkg.Package.Dir)
			if err != nil {
				errs = append(errs, err)
				continue
			}
			_, pkgName := path.Split(k)
			err = injectCache(v, pkgName, fmt.Sprintf("%s/%s", pkg.Package.Dir, pkg.Package.GoFiles[0]))
			if err != nil {
				errs = append(errs, err)
				continue
			}
		}
	}
	return errs
}

// InjectCacheCounters generate a file _cover_http_apis.go besides the main.go file
func injectCache(covers []*PackageCover, pkg, dest string) error {
	f, err := os.Create(dest)
	if err != nil {
		return err
	}

	if err := coverParentFileTmpl.Execute(f, pkg); err != nil {
		return err
	}

	if err := coverParentVarsTmpl.Execute(f, covers); err != nil {
		return err
	}
	return nil
}

func checkCacheDir(p string) error {
	_, err := os.Stat(p)
	if os.IsNotExist(err) {
		err := os.Mkdir(p, 0755)
		if err != nil {
			return err
		}
	}
	return nil
}

func injectGlobalCoverVarFile(ci *CoverInfo, content string) error {
	coverFile, err := os.Create(filepath.Join(ci.Target, ci.GlobalCoverVarImportPath, "cover.go"))
	if err != nil {
		return err
	}
	defer coverFile.Close()

	packageName := "package " + filepath.Base(ci.GlobalCoverVarImportPath) + "\n\n"

	_, err = coverFile.WriteString(packageName)
	if err != nil {
		return err
	}
	_, err = coverFile.WriteString(content)

	return err
}
